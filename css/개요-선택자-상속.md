*기본문법
 - 선택자 { 속성: 속성값; 속성: 속성값; }
 - 선택자 {
	 속성: 속성값;
	 속성: 속성값;
   }
 - 선택자(selector) 역할
  - 선택자로써 tag, id, class 사용 가능
  - HTML의 특정한 부분을 선택하는 역할을 한다
 - 속성(property) 과 값(value)의 역할
  - 검색된 대상에 지정될 css 명령
  - div {
	  color: red;			// color가 속성, red가 값
	  font-size: 20px;
	  font-weight: bold;
  }

*선언방식
 - 인라인(in-line) 방식
  - HTML요소에 직접 작성
  - <div style="color: red; font-size: 20px; font-weight: bold;">HELLO</div>
  - 선택자가 필요없다 바로 그 대상에 직접 입력하기 때문에
 - 내장(embedded) 방식
  - HTML <style></style>안에 작성
  - <head>
		<style>
			div {
				color: red;
				font-size: 20px;
				font-weight: bold;
			}
		</style>
	</head>
	<body>
		<div>HELLO</div>
	</body>
 - 링크(link) 방식
  - HTML <link> 를 이용해 외부 문서를 CSS로 불러와 적용
  - <head>
		<link rel="stylesheet" href="css/common.css">
  	</head>
	<body>
		<div>HELLO</div>
	</body>
  - 이 방식을 추천
 - @import 방식
  - CSS @import를 이용해 외부 문서로 CSS를 불러와 적용
  - <head>
		<link rel="stylesheet" href="css/common1.css">	<!-- HTML이 외부 CSS를 가져오는 방식 -->
  	</head>
	<body>
		<div>HELLO</div>
	</body>
  - @import url("./common2.css");	/* CSS가 외부 CSS를 가져오는 방식 -->
  - HTML에서 CSS를 호출할때는 "병렬방식"으로 호출, import는 가져오고 가져온 파일에 import가 있으면 다 가져온 후 또 가져오고.. "직렬방식"으로 호출하게 된다
 
*기본 선택자
 - 전체 선택자 (Universal Selector)
  - 모든 요소를 선택 (*)
  - * {
	  color: red;	/* 전체 태그, 폰트 색깔을 다 red로 만들겠다 */
    }
 - 태그 선택자 (Type Selector)
  - 태그이름 요소(Element) 선택
  - div {			/* 앞에 기호가 없기 때문에 태그 선택자로 볼 수 있다 */
	  color: red;
    }
 - 클래스 선택자 (Class Selector)
  - HTML class속성을 사용하는 요소 선택 (.클래스명)
  - .orange {		/* 점(.)이 붙고 이름이 있는 것은 클래스 선택자이다 */
	  color: red;
   }
 - 아이디 선택자 (ID Selector)
  - HTML id 속성을 사용하는 요소 선택 (#아이디)
  - HTML 에서 유일해야하는 값이여야 한다
  - #orange {
	  color: red;
    }

*복합 선택자
 - 일치 선택자(Basic Combinator)
  - 기본선택자x기본선택자y를 동시에 만족하는 요소 선택 (xy)
  - span.orange {	/* 태그와 클래스가 붙어있는 선택자, span태그이면서 orange클래스를 선택 */
	  color: red;
   }
    <div>
	  <ul>
	    <li>a</li>
	    <li class="orange">b</li>
	  </ul>
	  <div>c</div>
	  <span class="orange">d</span>	<!-- 선택됨 -->
    </div>
 - 자식 선택자(Child Combinator)
  - x선택자의 자식요소 y를 선택 (x > y)
  - ul > .orange {	/* ul 태그의 자식 선택자 .orange를 선택, ul은 조건이고 .orange는 검색 */
	  color: red;
    }
	<div>
	  <ul>
	   <li>a</li>
	   <li class="orange">b</li>	<!-- 선택됨 -->
	  </ul>
	  <div>c</div>
	  <span class="orange">d</span>
    </div>
 - 후손(하위) 선택자(Descendant Combinator)
  - 특정 선택자x의 후손(하위) 선택자 y를 선택 (x y)(띄어쓰기)
  - 제일 상위에 있는 div 밑에 속한 요소들은 다 후손(자식) 요소들이고, li입장에서 위에있는 요소들은 모두 다 조상(부모) 요소들이다
  - div .orange {
	  color: red;
    }
	<div>
	  <ul>
	   <li>a</li>
	   <li class="orange">b</li>	<!-- 선택됨 -->
	  </ul>
	  <div>c</div>
	  <span class="orange">d</span> <!-- 선택됨 -->
    </div>
 - 인접 형제 선택자(Adjacent Sibling Combinator)
  - 특정 선택자x의 다음 형제 요소y하나만 선택(x + y)
  - .orange + li {
	  color: red;
    }
    <ul>
	  <li>a</li>
	  <li>b</li>
	  <li class="orange">c</li>
	  <li>d</li> <!-- 선택됨 -->
	  <li>e</li>
	</ul>
 - 일반 형제 선택자(General Sibling Combinator)
  - 특정 선택자x의 다음 형제 요소y를 모두 선택 (x ~ y)
  - .orange ~ li {
	  color: red;
    }
    <ul>
	  <li>a</li>
	  <li>b</li>
	  <li class="orange">c</li>
	  <li>d</li> <!-- 선택됨 -->
	  <li>e</li> <!-- 선택됨 -->
	</ul>

*상속
 - 하위 요소들에게 상속하는 개념
 - .ecosystem {
	 color: red;
   }
   <div class="ecosystem">a
     <div class="xxx">b				<!-- color: red; -->
	 	<div class="yyy">c</div>	<!-- color: red; -->
		<div class="zzz">d</div>	<!-- color: red; -->
	 </div>
	 <div class="kkk">e</div>		<!-- color: red; -->
   </div>
 - 상속되는 속성들 (글짜를 다루는 속성들이 기본적으로 상속된다)
  - font
   - font-size
   - font-weight
   - font-style
   - line-height
   - font-family
  - color
  - text-align
  - text-indent
  - text-decoration
  - letter-spacing
  - opacity
  - etc...
 - 강제 상속
  - <div class="parent">
	  <div class="child"></div>
    </div>
	<style>
	  .parent {
		  position: absolute;	/* 상속되지 않는 속성과 값 */
	  }
	  .child {
		  position: inherit;	/* 강제 상속 받아 position: absolute; 와 동일 */
	  }
	</style>

*우선순위
 - 같은 요소가 여러 선언의 대상이 될 경우, 어떤 선언이 CSS 속성을 우선 적용할지 결정하는 방법
  1.명시도 점수가 높은 선인이 우선(명시도)
  2.점수가 같은 경우, 가장 마지막에 해석한(늦게 작성한) 선언이 우선
  3.명시도는 '상속' 규칙보다 우선(중요도), 즉 상속은 우선순위가 낮다
  4.!important 가 적용된 선언 방식이 다른 모든 방식보다 우선(중요도)
 - 가장 중요 (!import)
  - 가장 우선 (점수: 무한대)
 - 인라인 선언 방식
  - 태그에 style속성을 바로 사용 (점수: 1000점)
 - 아이디(ID Selector)
  - 고유한 요소이기 때문에(점수: 100점)
 - 클래스(Class Selector)
  - (점수: 10점)
  - 가상 클래스도 포함이지만, 부정 클래스 선택자는 점수로 취급하지 않는다
 - 태그(Type Selector)
  - (점수: 1점)
 - 전체(Universal Selector)
  - (점수: 0점)
 - 상속
  - (점수: 계산하지 않음)

*가상 클래스 선택자(Pseudo-Classes Selectors)
 - 가상 클래스(:이름)이고 혼동하지 말것이 가상 요소 선택자(::이름)가 있다
 - hover
  - 어떠한 요소x에 마우스(포인터)가 올라가 있는 동안만 x 선택 (x:hover)
 - active
  - 어떠한 요소x에 클릭하는 동안에만 x를 선택 (x:active)
 - focus
  - 어떠한 요소x에 포커스 된 동안에만 x 선택 (x:focus)
  - 대화형 컨텐츠에서 사용 가능 (input*, img, tabindex)

*first-child
 - 특정요소 x가 형제 요소 중 첫번째 요소라면 선택 (x:first-child)
 - .fruits li:first-child {
	 color: red;
   }
   <ul class="fruits">
    <li>a</li>	<!-- 선택 -->
    <li>b</li>
    <li>c</li>
    <li>d</li>
   </ul>

*last-child
 - 특정요소 x의 형제 요소 중 마지막 요소라면 선택
 - .fruits li:last-child {
	 color: red;
   }
   <ul class="fruits">
    <li>a</li>
    <li>b</li>
    <li>c</li>
    <li>d</li>	<!-- 선택 -->
   </ul>

*nth-child
 - 몇번째 child를 선택할 것인지 선택
 - 특정요소 x의 형제 요소 중 n번째 요소라면 선택 (n키워드 사용시 0 부터 해석, 아니라면 1 부터 해석)(x:nth-child(n))
 - .fruits li:nth-child(2) {
	 color: red;
   }
   <ul class="fruits">
    <li>a</li>
    <li>b</li>	<!-- 선택 -->
    <li>c</li>
    <li>d</li>
   </ul>
 - .fruits li:nth-child(2n) {		<!-- 2xn=0, 2x1=2, 2x2=4, ... -->
	 color: red;
   }
   <ul class="fruits">
    <li>a</li>
    <li>b</li>	<!-- 선택 -->
    <li>c</li>
    <li>d</li>	<!-- 선택 -->
   </ul>
 - .fruits li:nth-child(n+3) {		<!-- 0+3=3, 1+3=4, 2+3=5, ... -->
	 color: red;
   }
   <ul class="fruits">
    <li>a</li>
    <li>b</li>
    <li>c</li>	<!-- 선택 -->
    <li>d</li>	<!-- 선택 -->
   </ul>
 - 주의 사항
  - .fruits p:nth-child(1) {	<!-- .fruits의 첫번째 자식 요소가 p 태그가 아니기 때문에 선택되지 않는다 -->
	  color: red;
    }
	<!-- 선택된 요소 없음 -->
    <div class="fruits">
     <div>a</div>
     <p>b</p>
     <p>c</p>
     <span>d</span>
    </div>